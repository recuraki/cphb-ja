\chapter{はじめに - Introduction}

競技プログラミングとは次の二つのトピックからなっている。
アルゴリズムの設計とアルゴリズムの実装である。
%Competitive programming combines two topics:
%(1) the design of algorithms and (2) the implementation of algorithms.


\key{アルゴリズムの設計} は問題解決と数学的思考です。
問題を分析し、想像的に解決することが求められます。
そのアルゴリズムは正確で効率的であることが求められ、多くの問題でポイントとなるのは効率的なアルゴリズムの考察です。

アルゴリズムの理論的な知識は、競技プログラミングに取り組むにあたり重要な要素です。
一般的な問題は、よく知られたテクニックと新しい考察の組み合わせからなります。
また、競技プログラミングに登場するテクニックは、アルゴリズムの科学的研究の基礎でもあります。

The \key{アルゴリズムの実装} にはプログラミングスキルが大切になります。
競技プログラミングでは、実装したアルゴリズムはテストケースでテストすることで採点されます。
このため、アルゴリズムの考察に加えて、その実装も正しくなければなりません。


コンテストでの良いコーディングスタイルとはシンプルで簡潔なものです。
コンテストの時間は限られるため、プログラムは素早く書かなければなりません。
通常のソフトウェア開発とは異なり、プログラムは短いですし（どんなに長くても数百行程度）、
コンテスト後にメンテナンスする必要はありません。

\section{プログラミング言語}

\index{プログラミング言語}

現在(2018年)最も使われているプログラミング言語はC++, Python, Javaです。
Google Code Jam 2017の上位3000人をみてみると、
79 \% が C++,
16 \% が Python,
8 \% が Java を使用しています\cite{goo17}.
また、複数の言語を使い分けている参加者もいます。

C++が競技プログラミングに最適と考える人は多く、C++はほぼどのコンテストでも利用できます。
C++を使う利点は次の通りです。非常に効率的な言語であり
標準ライブラリには データ構造やアルゴリズムが豊富に揃っていること。

一方で複数の言語を使いこなし、それぞれの強みを理解するのも良いアプローチです。
例えば、問題に(64bitや128bitを超える)大きな整数が必要な場合、
Pythonは標準で大きな整数を扱えるため良い選択肢になります。
とはいえ、コンテストの多くではあるプログラミング言語を選択したことで
アンフェアにならないようにされています。

All example programs in this book are written in C++,
and the standard library's
data structures and algorithms are often used.
The programs follow the C++11 standard,
which can be used in most contests nowadays.
If you cannot program in C++ yet,
now is a good time to start learning.
本書で紹介するプログラムはC++11で書かれており、多くのプログラミングコンテストで使うことができます(訳註：2018年はC++17対応のコンテストサイトは少なかった)。
標準ライブラリのデータ構造やアルゴリズムが多く使用されています。
C++でプログラミングができない人は、今が勉強を始める良い機会です！

\subsubsection{C++のテンプレート}

C++での競技プログラミング用テンプレートを以下に示します。

\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;

int main() {
    // solution comes here
}
\end{lstlisting}

最初の\texttt{\#include}は\texttt{g++}の機能で標準ライブラリを一括で読み込むことができます。
つまり、よく使う\texttt{iostream},
\texttt{vector}や\texttt{algorithm},
などが使えるようになります。

\texttt{using}行は標準ライブラリの機能を一括で使えるようにします。
\texttt{using}がない場合は
\texttt{std::cout}と書かないと行けませんが、これがあることで
\texttt{cout}だけで十分になります。

そして、このコードは以下のようにコンパイルします。

\begin{lstlisting}
g++ -std=c++11 -O2 -Wall test.cpp -o test
\end{lstlisting}

このコマンドは\texttt{test.cpp}から
\texttt{test}という実行形式のバイナリを作成します。
(\texttt{-std=c++11})はC++11としてコンパイルすることを、
(\texttt{-O2})は最適化を行うことを、
(\texttt{-Wall})は全てのWarningを出すことを示します。

\section{入出力}

\index{入出力}

ほとんどのコンテストでは標準入出力ストリームが用いられます。

C++では標準入出力には、
入力に\texttt{cin}が使われ、出力に\texttt{cout}が使われます。
さらにCの関数である
\texttt{scanf}と\texttt{printf}も利用できます。

通常、入力はスペースと改行で区切られた数字と文字列で構成されており、
これらは以下のように
\texttt{cin}でストリームから読み込むことができます。

\begin{lstlisting}
int a, b;
string x;
cin >> a >> b >> x;
\end{lstlisting}


cinは各要素の間に少なくとも1つのスペースか改行があることを前提に動作します。
つまり、このコードは次の両方の入力を読み取ることができます。

\begin{lstlisting}
123 456 monkey
\end{lstlisting}
\begin{lstlisting}
123    456
monkey
\end{lstlisting}
The \texttt{cout}は次のように出力に使います。
\begin{lstlisting}
int a = 123, b = 456;
string x = "monkey";
cout << a << " " << b << " " << x << "\n";
\end{lstlisting}

入出力は時として実行時間のボトルネックになります。
以下を用いることで効率的な入出力が可能です。

\begin{lstlisting}
ios::sync_with_stdio(0);
cin.tie(0);
\end{lstlisting}

\texttt{"\textbackslash n"}用いると
\texttt{endl}よりも高速です。
なぜなら、\texttt{endl} は毎回flushを行うからです。

cinとcoutに代わり、C言語では\texttt{scanf}と\texttt{printf}が存在します。
通常、これらの関数は少し速いに動作しますが、使用するのが少し複雑になります。。
次のコードは入力から2つの整数を読み取ります。
\begin{lstlisting}
int a, b;
scanf("%d %d", &a, &b);
\end{lstlisting}
また、次の通り出力します。
\begin{lstlisting}
int a = 123, b = 456;
printf("%d %d\n", a, b);
\end{lstlisting}

文字列の読み込みでは空白ごと読み込みたいことがあり、
これは\texttt{getline}関数を使います。

\begin{lstlisting}
string s;
getline(cin, s);
\end{lstlisting}

また、読み込みたい文字列の数がわからない場合は次のように処理します。
\begin{lstlisting}
while (cin >> x) {
    // code
}
\end{lstlisting}
こうすることで入力に利用可能なデータがなくなるまで、入力から次々と要素を読み込みます。

In some contest systems, files are used for
input and output.
An easy solution for this is to write
the code as usual using standard streams,
but add the following lines to the beginning of the code:
\begin{lstlisting}
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
\end{lstlisting}
After this, the program reads the input from the file
''input.txt'' and writes the output to the file
''output.txt''.

\section{数字を扱う - Working with numbers}

\index{整数 - integer}

\subsubsection{整数 - Integers}

競技プログラミングで最もよく使われる整数型は\texttt{int}という32ビットの型す。
値の範囲は$-2^{31} \ldots 2^{31}-1$、競技プログラミングでは
$-2 \cdot 10^9 \ldots 2 \cdot 10^9$と考えても良いでしょう。
\texttt{int} 型では不十分な場合は， 64ビット型の\texttt{long long}
を使用することができます.この型の値域は
$-2^{63} \ldots 2^{63}-1$で、
同様におおよそ、$-9 \cdot 10^{18} \ldots 9 \cdot 10^{18}$です。

次のコードでは、long long変数を定義しています。

\texttt{long long} variable:
\begin{lstlisting}
long long x = 123456789123456789LL;
\end{lstlisting}
数字の後の\texttt{LL}はこの数字が
\texttt{long long}であるということです。

\texttt{long long}を使う時によくある過ちは
\texttt{int} との演算をしてしまうケースです。
次の計算はうまくいきません。

\begin{lstlisting}
int a = 123456789;
long long b = a*a;
cout << b << "\n"; // -1757895751
\end{lstlisting}

変数\texttt{b}は\texttt{long long}ですが、
\texttt{a*a}は\texttt{int}同士の掛け算で、この結果は\texttt{int}となります。
そして、(intで表現できる範囲を超えてしまうので)誤った結果となります。
この例では\texttt{a} を \texttt{long long} に変更するか、
\texttt{(long long)a*a}というように結果をキャストすることで正しく動作します。

通常、コンテストの問題は、\texttt{long long}型で十分なように設定されています。
時折、\texttt{g++}コンパイラが128ビットの \texttt{\_\_int128\_t}型も提供していることを知っておくと，
値域が$-2^{127} \ldots 2^{127}-1$、つまり、 $-10^{38} \ldots 10^{38}$の範囲を扱えます。
しかし，この型は、すべてのコンテストで利用できるわけではありません。（訳註:また多少低速になることもあります）

\subsubsection{モジュロ演算 - Modular arithmetic}

\index{剰余 - remainder}
\index{モジュロ演算 - modular arithmetic}

$x \bmod m$というのは
 $x$を$m$で割った時のあまりです。
例えば、$17 \bmod 5 = 2$です。
なぜなら、$17 = 3 \cdot 5 + 2$であるため。

答えの数が非常に大きくなる問題では、
時々「$m$で割った数を答えよ」と指示されます。
例えば、$10^9+7$などがあります。
これにより答えが非常に大きくても
\texttt{int} や \texttt{long long}の値域で十分になります。

余りの重要な性質は、足し算、引き算、掛け算において、演算の前に余りを取ることができることです。

\[
\begin{array}{rcr}
(a+b) \bmod m & = & (a \bmod m + b \bmod m) \bmod m \\
(a-b) \bmod m & = & (a \bmod m - b \bmod m) \bmod m \\
(a \cdot b) \bmod m & = & (a \bmod m \cdot b \bmod m) \bmod m
\end{array}
\]

つまり、演算のたびに余りを取れば、数字が大きくなりすぎることがありません。

$n$までの階乗である$n!$をmod $m$で求めます。
\begin{lstlisting}
long long x = 1;
for (int i = 2; i <= n; i++) {
    x = (x*i)%m;
}
cout << x%m << "\n";
\end{lstlisting}

通常の余りは$0\ldots m-1$で表現されます。
しかし、C++やいくつかの言語ではマイナスの数に対する余りは
負の数になってしまいます。

これを解決するにはまずあまりを求め、
マイナスであった場合は$m$を加算することです。
\begin{lstlisting}
x = x%m;
if (x < 0) x += m;
\end{lstlisting}
これはあくまで負の可能性となることがある場合にのみ必要になります。

\subsubsection{浮動小数点数 - Floating point numbers}

\index{浮動小数点数 - floating point number}

競技プログラミングで多く用いられるのは
64-bitの浮動小数点型\texttt{double}で、
\texttt{g++}の拡張である
80-bit 浮動小数点型の\texttt{long double}もあります。
ほとんどのケースでは\texttt{double}で十分ですが、
\texttt{long double} の方がより正確です。

答えに必要な精度は、通常、問題文の中で示されています。
答えを出力する簡単な方法は，\texttt{printf}関数を使い，
書式文字列で小数点以下の桁数を与える方法です。
例えば，次のコードは，$x$の値を小数点以下9桁で表示します.

\begin{lstlisting}
printf("%.9f\n", x);
\end{lstlisting}

浮動小数点数を使う際の留意点は
浮動小数点数として正確に表現できない数値があって丸め誤差が発生することです。
例えば、次のようなコードの結果は驚くべきものでしょう。

\begin{lstlisting}
double x = 0.3*3+0.1;
printf("%.20f\n", x); // 0.99999999999999988898
\end{lstlisting}

正しい値は1ですが、丸め誤差のために$x$の値が1より少し小さくなっています。
このまま\texttt{==}演算子で浮動小数点数を比較すると、
精度誤差のために本来等しいはずの値が等しくなくなる可能性があります。
浮動小数点数の比較に適した方法は、
2つの数値の差が$\varepsilon$($\varepsilon$は小さな数)より小さければ等しいと仮定することです。

実際には、次のように数値を比較することができます($\varepsilon=10^{-9}$)。

\begin{lstlisting}
if (abs(a-b) < 1e-9) {
    // a and b are equal
}
\end{lstlisting}

なお、ある程度までの整数は正確に表現できます。
\texttt{double}の場合は$2^{53}$までの整数は正しく表現できます。

\section{短く書く - Shortening code}

競技プログラミングでは、
速くプログラムを書くことが求められるので、短いコードが理想的です。
そのため、競技志向のプログラマは、
データ型などのコードに短い名前を定義することが多くなります。

\subsubsection{型の名前 - Type names}
\index{tuppdef@\texttt{typedef}}
\texttt{typedef}を用いるとデータ型を短くできます。
例えば、次のように\texttt{long long}という長い名前を
\texttt{ll}とすることができます。

\begin{lstlisting}
typedef long long ll;
\end{lstlisting}

このように宣言することで
\begin{lstlisting}
long long a = 123456789;
long long b = 987654321;
cout << a*b << "\n";
\end{lstlisting}
となっていたコードが以下のようにかけます。
\begin{lstlisting}
ll a = 123456789;
ll b = 987654321;
cout << a*b << "\n";
\end{lstlisting}

\texttt{typedef}はもう少し複雑な型も表現できます。
例えば次のように、整数のvectorや、整数のpairを宣言できます。

\begin{lstlisting}
typedef vector<int> vi;
typedef pair<int,int> pi;
\end{lstlisting}

\subsubsection{マクロ -  Macros}
\index{マクロ - macro}

\key{マクロ - macros}も短く書くのに有効な手法です。
マクロは、コード中の特定の文字列をコンパイル前に変更します。
C++ では、マクロは\texttt{\#define} キーワードを使って定義します。

例えば、次のようなマクロを定義することができます。

\begin{lstlisting}
#define F first
#define S second
#define PB push_back
#define MP make_pair
\end{lstlisting}
これによって次のようなコードが、
\begin{lstlisting}
v.push_back(make_pair(y1,x1));
v.push_back(make_pair(y2,x2));
int d = v[i].first+v[i].second;
\end{lstlisting}
次のようにかけるのです。
\begin{lstlisting}
v.PB(MP(y1,x1));
v.PB(MP(y2,x2));
int d = v[i].F+v[i].S;
\end{lstlisting}

また、マクロは引数を持てるのでループなどを短く書くのに役立ちます。

\begin{lstlisting}
#define REP(i,a,b) for (int i = a; i <= b; i++)
\end{lstlisting}
このような定義をしておけば、
\begin{lstlisting}
for (int i = 1; i <= n; i++) {
    search(i);
}
\end{lstlisting}
この記述が以下のようにかけます。
\begin{lstlisting}
REP(i,1,n) {
    search(i);
}
\end{lstlisting}

ただ、マクロは時折デバッグを難しくすることがあるので注意してください。
\begin{lstlisting}
#define SQ(a) a*a
\end{lstlisting}
このような平方根を求めるものがあり、
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
こうしたとすると、次のように展開されます。
\begin{lstlisting}
cout << 3+3*3+3 << "\n"; // 15
\end{lstlisting}

このマクロは次のように書くべきでした。
\begin{lstlisting}
#define SQ(a) (a)*(a)
\end{lstlisting}
この時、
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
この処理は次のように動作し、予想した通りに動きますね。
\begin{lstlisting}
cout << (3+3)*(3+3) << "\n"; // 36
\end{lstlisting}


\section{数学 - Mathematics}

競技プログラミングで数学は重要な役割を担っており、
数学の能力がなければ競技用プログラマとして成功することはできません。
この本の後半で必要となる重要な数学的概念と公式について説明します。

\subsubsection{加算に関する公式 - Sum formulas}

まず基本的な式を紹介します。
\[\sum_{x=1}^n x^k = 1^k+2^k+3^k+\ldots+n^k,\]
ここで、$k$は正の整数であり、次数$k + 1$の多項式となる閉形式を持っている。
例えば
where $k$ is a positive integer,
has a closed-form formula that is a
polynomial of degree $k+1$.
For example\footnote{\index{Faulhaber's formula}
There is even a general formula for such sums, called \key{Faulhaber's formula},
but it is too complex to be presented here.},
\[\sum_{x=1}^n x = 1+2+3+\ldots+n = \frac{n(n+1)}{2}\]
and
\[\sum_{x=1}^n x^2 = 1^2+2^2+3^2+\ldots+n^2 = \frac{n(n+1)(2n+1)}{6}.\]

An \key{arithmetic progression} is a \index{arithmetic progression}
sequence of numbers
where the difference between any two consecutive
numbers is constant.
For example,
\[3, 7, 11, 15\]
is an arithmetic progression with constant 4.
The sum of an arithmetic progression can be calculated
using the formula
\[\underbrace{a + \cdots + b}_{n \,\, \textrm{numbers}} = \frac{n(a+b)}{2}\]
where $a$ is the first number,
$b$ is the last number and
$n$ is the amount of numbers.
For example,
\[3+7+11+15=\frac{4 \cdot (3+15)}{2} = 36.\]
The formula is based on the fact
that the sum consists of $n$ numbers and
the value of each number is $(a+b)/2$ on average.

\index{geometric progression}
A \key{geometric progression} is a sequence
of numbers
where the ratio between any two consecutive
numbers is constant.
For example,
\[3,6,12,24\]
is a geometric progression with constant 2.
The sum of a geometric progression can be calculated
using the formula
\[a + ak + ak^2 + \cdots + b = \frac{bk-a}{k-1}\]
where $a$ is the first number,
$b$ is the last number and the
ratio between consecutive numbers is $k$.
For example,
\[3+6+12+24=\frac{24 \cdot 2 - 3}{2-1} = 45.\]

This formula can be derived as follows. Let
\[ S = a + ak + ak^2 + \cdots + b .\]
By multiplying both sides by $k$, we get
\[ kS = ak + ak^2 + ak^3 + \cdots + bk,\]
and solving the equation
\[ kS-S = bk-a\]
yields the formula.

A special case of a sum of a geometric progression is the formula
\[1+2+4+8+\ldots+2^{n-1}=2^n-1.\]

\index{harmonic sum}

A \key{harmonic sum} is a sum of the form
\[ \sum_{x=1}^n \frac{1}{x} = 1+\frac{1}{2}+\frac{1}{3}+\ldots+\frac{1}{n}.\]

An upper bound for a harmonic sum is $\log_2(n)+1$.
Namely, we can
modify each term $1/k$ so that $k$ becomes
the nearest power of two that does not exceed $k$.
For example, when $n=6$, we can estimate
the sum as follows:
\[ 1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\frac{1}{5}+\frac{1}{6} \le
1+\frac{1}{2}+\frac{1}{2}+\frac{1}{4}+\frac{1}{4}+\frac{1}{4}.\]
This upper bound consists of $\log_2(n)+1$ parts
($1$, $2 \cdot 1/2$, $4 \cdot 1/4$, etc.),
and the value of each part is at most 1.

\subsubsection{Set theory}

\index{set theory}
\index{set}
\index{intersection}
\index{union}
\index{difference}
\index{subset}
\index{universal set}
\index{complement}

A \key{set} is a collection of elements.
For example, the set
\[X=\{2,4,7\}\]
contains elements 2, 4 and 7.
The symbol $\emptyset$ denotes an empty set,
and $|S|$ denotes the size of a set $S$,
i.e., the number of elements in the set.
For example, in the above set, $|X|=3$.

If a set $S$ contains an element $x$,
we write $x \in S$,
and otherwise we write $x \notin S$.
For example, in the above set
\[4 \in X \hspace{10px}\textrm{and}\hspace{10px} 5 \notin X.\]

\begin{samepage}
New sets can be constructed using set operations:
\begin{itemize}
\item The \key{intersection} $A \cap B$ consists of elements
that are in both $A$ and $B$.
For example, if $A=\{1,2,5\}$ and $B=\{2,4\}$,
then $A \cap B = \{2\}$.
\item The \key{union} $A \cup B$ consists of elements
that are in $A$ or $B$ or both.
For example, if $A=\{3,7\}$ and $B=\{2,3,8\}$,
then $A \cup B = \{2,3,7,8\}$.
\item The \key{complement} $\bar A$ consists of elements
that are not in $A$.
The interpretation of a complement depends on
the \key{universal set}, which contains all possible elements.
For example, if $A=\{1,2,5,7\}$ and the universal set is
$\{1,2,\ldots,10\}$, then $\bar A = \{3,4,6,8,9,10\}$.
\item The \key{difference} $A \setminus B = A \cap \bar B$
consists of elements that are in $A$ but not in $B$.
Note that $B$ can contain elements that are not in $A$.
For example, if $A=\{2,3,7,8\}$ and $B=\{3,5,8\}$,
then $A \setminus B = \{2,7\}$.
\end{itemize}
\end{samepage}

If each element of $A$ also belongs to $S$,
we say that $A$ is a \key{subset} of $S$,
denoted by $A \subset S$.
A set $S$ always has $2^{|S|}$ subsets,
including the empty set.
For example, the subsets of the set $\{2,4,7\}$ are
\begin{center}
$\emptyset$,
$\{2\}$, $\{4\}$, $\{7\}$, $\{2,4\}$, $\{2,7\}$, $\{4,7\}$ and $\{2,4,7\}$.
\end{center}

Some often used sets are
$\mathbb{N}$ (natural numbers),
$\mathbb{Z}$ (integers),
$\mathbb{Q}$ (rational numbers) and
$\mathbb{R}$ (real numbers).
The set $\mathbb{N}$
can be defined in two ways, depending
on the situation:
either $\mathbb{N}=\{0,1,2,\ldots\}$
or $\mathbb{N}=\{1,2,3,...\}$.

We can also construct a set using a rule of the form
\[\{f(n) : n \in S\},\]
where $f(n)$ is some function.
This set contains all elements of the form $f(n)$,
where $n$ is an element in $S$.
For example, the set
\[X=\{2n : n \in \mathbb{Z}\}\]
contains all even integers.

\subsubsection{Logic}

\index{logic}
\index{negation}
\index{conjuction}
\index{disjunction}
\index{implication}
\index{equivalence}

The value of a logical expression is either
\key{true} (1) or \key{false} (0).
The most important logical operators are
$\lnot$ (\key{negation}),
$\land$ (\key{conjunction}),
$\lor$ (\key{disjunction}),
$\Rightarrow$ (\key{implication}) and
$\Leftrightarrow$ (\key{equivalence}).
The following table shows the meanings of these operators:

\begin{center}
\begin{tabular}{rr|rrrrrrr}
$A$ & $B$ & $\lnot A$ & $\lnot B$ & $A \land B$ & $A \lor B$ & $A \Rightarrow B$ & $A \Leftrightarrow B$ \\
\hline
0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 \\
1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}

The expression $\lnot A$ has the opposite value of $A$.
The expression $A \land B$ is true if both $A$ and $B$
are true,
and the expression $A \lor B$ is true if $A$ or $B$ or both
are true.
The expression $A \Rightarrow B$ is true
if whenever $A$ is true, also $B$ is true.
The expression $A \Leftrightarrow B$ is true
if $A$ and $B$ are both true or both false.

\index{predicate}

A \key{predicate} is an expression that is true or false
depending on its parameters.
Predicates are usually denoted by capital letters.
For example, we can define a predicate $P(x)$
that is true exactly when $x$ is a prime number.
Using this definition, $P(7)$ is true but $P(8)$ is false.

\index{quantifier}

A \key{quantifier} connects a logical expression
to the elements of a set.
The most important quantifiers are
$\forall$ (\key{for all}) and $\exists$ (\key{there is}).
For example,
\[\forall x (\exists y (y < x))\]
means that for each element $x$ in the set,
there is an element $y$ in the set
such that $y$ is smaller than $x$.
This is true in the set of integers,
but false in the set of natural numbers.

Using the notation described above,
we can express many kinds of logical propositions.
For example,
\[\forall x ((x>1 \land \lnot P(x)) \Rightarrow (\exists a (\exists b (a > 1 \land b > 1 \land x = ab))))\]
means that if a number $x$ is larger than 1
and not a prime number,
then there are numbers $a$ and $b$
that are larger than $1$ and whose product is $x$.
This proposition is true in the set of integers.

\subsubsection{Functions}

The function $\lfloor x \rfloor$ rounds the number $x$
down to an integer, and the function
$\lceil x \rceil$ rounds the number $x$
up to an integer. For example,
\[ \lfloor 3/2 \rfloor = 1 \hspace{10px} \textrm{and} \hspace{10px} \lceil 3/2 \rceil = 2.\]

The functions $\min(x_1,x_2,\ldots,x_n)$
and $\max(x_1,x_2,\ldots,x_n)$
give the smallest and largest of values
$x_1,x_2,\ldots,x_n$.
For example,
\[ \min(1,2,3)=1 \hspace{10px} \textrm{and} \hspace{10px} \max(1,2,3)=3.\]

\index{factorial}

The \key{factorial} $n!$ can be defined
\[\prod_{x=1}^n x = 1 \cdot 2 \cdot 3 \cdot \ldots \cdot n\]
or recursively
\[
\begin{array}{lcl}
0! & = & 1 \\
n! & = & n \cdot (n-1)! \\
\end{array}
\]

\index{Fibonacci number}

The \key{Fibonacci numbers}
%\footnote{Fibonacci (c. 1175--1250) was an Italian mathematician.}
arise in many situations.
They can be defined recursively as follows:
\[
\begin{array}{lcl}
f(0) & = & 0 \\
f(1) & = & 1 \\
f(n) & = & f(n-1)+f(n-2) \\
\end{array}
\]
The first Fibonacci numbers are
\[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \ldots\]
There is also a closed-form formula
for calculating Fibonacci numbers, which is sometimes called
\index{Binet's formula} \key{Binet's formula}:
\[f(n)=\frac{(1 + \sqrt{5})^n - (1-\sqrt{5})^n}{2^n \sqrt{5}}.\]

\subsubsection{Logarithms}

\index{logarithm}

The \key{logarithm} of a number $x$
is denoted $\log_k(x)$, where $k$ is the base
of the logarithm.
According to the definition,
$\log_k(x)=a$ exactly when $k^a=x$.

A useful property of logarithms is
that $\log_k(x)$ equals the number of times
we have to divide $x$ by $k$ before we reach
the number 1.
For example, $\log_2(32)=5$
because 5 divisions by 2 are needed:

\[32 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1 \]

Logarithms are often used in the analysis of
algorithms, because many efficient algorithms
halve something at each step.
Hence, we can estimate the efficiency of such algorithms
using logarithms.

The logarithm of a product is
\[\log_k(ab) = \log_k(a)+\log_k(b),\]
and consequently,
\[\log_k(x^n) = n \cdot \log_k(x).\]
In addition, the logarithm of a quotient is
\[\log_k\Big(\frac{a}{b}\Big) = \log_k(a)-\log_k(b).\]
Another useful formula is
\[\log_u(x) = \frac{\log_k(x)}{\log_k(u)},\]
and using this, it is possible to calculate
logarithms to any base if there is a way to
calculate logarithms to some fixed base.

\index{natural logarithm}

The \key{natural logarithm} $\ln(x)$ of a number $x$
is a logarithm whose base is $e \approx 2.71828$.
Another property of logarithms is that
the number of digits of an integer $x$ in base $b$ is
$\lfloor \log_b(x)+1 \rfloor$.
For example, the representation of
$123$ in base $2$ is 1111011 and
$\lfloor \log_2(123)+1 \rfloor = 7$.

\section{Contests and resources}

\subsubsection{IOI}

The International Olympiad in Informatics (IOI)
is an annual programming contest for
secondary school students.
Each country is allowed to send a team of
four students to the contest.
There are usually about 300 participants
from 80 countries.

The IOI consists of two five-hour long contests.
In both contests, the participants are asked to
solve three algorithm tasks of various difficulty.
The tasks are divided into subtasks,
each of which has an assigned score.
Even if the contestants are divided into teams,
they compete as individuals.

The IOI syllabus \cite{iois} regulates the topics
that may appear in IOI tasks.
Almost all the topics in the IOI syllabus
are covered by this book.

Participants for the IOI are selected through
national contests.
Before the IOI, many regional contests are organized,
such as the Baltic Olympiad in Informatics (BOI),
the Central European Olympiad in Informatics (CEOI)
and the Asia-Pacific Informatics Olympiad (APIO).

Some countries organize online practice contests
for future IOI participants,
such as the Croatian Open Competition in Informatics \cite{coci}
and the USA Computing Olympiad \cite{usaco}.
In addition, a large collection of problems from Polish contests
is available online \cite{main}.

\subsubsection{ICPC}

The International Collegiate Programming Contest (ICPC)
is an annual programming contest for university students.
Each team in the contest consists of three students,
and unlike in the IOI, the students work together;
there is only one computer available for each team.

The ICPC consists of several stages, and finally the
best teams are invited to the World Finals.
While there are tens of thousands of participants
in the contest, there are only a small number\footnote{The exact number of final
slots varies from year to year; in 2017, there were 133 final slots.} of final slots available,
so even advancing to the finals
is a great achievement in some regions.

In each ICPC contest, the teams have five hours of time to
solve about ten algorithm problems.
A solution to a problem is accepted only if it solves
all test cases efficiently.
During the contest, competitors may view the results of other teams,
but for the last hour the scoreboard is frozen and it
is not possible to see the results of the last submissions.

The topics that may appear at the ICPC are not so well
specified as those at the IOI.
In any case, it is clear that more knowledge is needed
at the ICPC, especially more mathematical skills.

\subsubsection{Online contests}

There are also many online contests that are open for everybody.
At the moment, the most active contest site is Codeforces,
which organizes contests about weekly.
In Codeforces, participants are divided into two divisions:
beginners compete in Div2 and more experienced programmers in Div1.
Other contest sites include AtCoder, CS Academy, HackerRank and Topcoder.

Some companies organize online contests with onsite finals.
Examples of such contests are Facebook Hacker Cup,
Google Code Jam and Yandex.Algorithm.
Of course, companies also use those contests for recruiting:
performing well in a contest is a good way to prove one's skills.

\subsubsection{Books}

There are already some books (besides this book) that
focus on competitive programming and algorithmic problem solving:

\begin{itemize}
\item S. S. Skiena and M. A. Revilla:
\emph{Programming Challenges: The Programming Contest Training Manual} \cite{ski03}
\item S. Halim and F. Halim:
\emph{Competitive Programming 3: The New Lower Bound of Programming Contests} \cite{hal13}
\item K. Diks et al.: \emph{Looking for a Challenge? The Ultimate Problem Set from
the University of Warsaw Programming Competitions} \cite{dik12}
\end{itemize}

The first two books are intended for beginners,
whereas the last book contains advanced material.

Of course, general algorithm books are also suitable for
competitive programmers.
Some popular books are:

\begin{itemize}
\item T. H. Cormen, C. E. Leiserson, R. L. Rivest and C. Stein:
\emph{Introduction to Algorithms} \cite{cor09}
\item J. Kleinberg and É. Tardos:
\emph{Algorithm Design} \cite{kle05}
\item S. S. Skiena:
\emph{The Algorithm Design Manual} \cite{ski08}
\end{itemize}
